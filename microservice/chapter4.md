## 集成

这个部分重点是在讲微服务边缘交互的，这一块是微服务里面最精妙，也最有可能出现问题的地方。我们按照上一章的原则、实践和标准三个层级来规划我们的集成工作，集成工作确实也需要架构师与其团队共同协商，最终能够协调出一个完整的方案，并进行落实。

## 四个原则

### 避免破坏性修改

尽量不要发生，在服务端的修改，不应当影响到消费方当前的使用。这里主要是想积极的避免对一侧边缘的修改，会非常频繁地引起另一侧边缘的修改，这样的修改成本过高

### 保证API的技术无关性

> 保证微服务之间通信方式的技术无关性是非常重要的，这就意味着，应该选择那种对微服务的具体实现技术有限制的集成方式

### 使你的服务易于消费方服务

这实质上是一个哲学问题，倒不是简单的说是在本行业内就应该如此，事实上确实在各个行业都应当如此，尤其是在服务业。我们小组曾经内部的组员也出现过一个接口写得让人抓狂的情况，而当对方提出相关修改意见的时候，总是用为了稳定不予修改这样的借口进行搪塞。

对于书中提到的提供客户端库这样的情况，实质上也是在项目中使用过这样的解决方法，会结合后文实践部分进行具体的描述。

### 隐藏内部实现细节

如果暴露了内部实现细节，一旦实现出现了修改，就很容易出现破坏性修改。

## 实践

### 共享数据库
> 我和同事在业界所遇到的最常见的集成形式就是数据库集成。使用这种方式时，如果其他服务想要从一鸽服务获取信息，可以直接访问数据库。如果想要修改，也可以直接在数据库中修改。
>
> 这使得外部系统能够看到内部实现细节，并与其绑定在一起
>
> 数据库是一个很大的共享API，但同时也非常不稳定。
>
> 为了不影响其他业务，我必须很小心地避免修改与其他服务相关的表结构。这种情况下，通常需要做大量的回归测试来保证功能的正确性

在共享数据库这个问题上，我吃过大亏。最初是想在代码层级上就做到统一，我们当时的开发“原则”就是尽可能的进行DRY来保证一致和快速进行开发，我们最开始是每一个微服务都有一个master分支，之后我们做了一些解耦的工作，比如通过submodule的方式将数据库的基底从业务逻辑中剥离，这确实是一种进步，但是这确实也成了本书中所提到的共享库，还是那种非常不稳定的情况，确实会出现修改一个字段导致多个服务都不可用的情况，然后为了避免这种情况的发生，我们专设一份负责该module的代码的merge，以及写了大量的单元测试进行测试。实质上这样耦合度还是高得离谱。

### 同步与异步、编排与协同

在此我把两个标题合在一起，是因为两个概念是指上基本是成对出现的。同步与编排，异步与协同两两成对。注意这里我们还没有深入到微服务边缘交互的细节中，我们只是在讲服务与服务之间的调用的拓扑结构。

> 编排会依赖于某个中心大脑来指导并驱动整个流程，作为中心控制点承担了太多职责，它会成为网状结构的中心枢纽以及很多逻辑的起点，而与其打交道的那些服务通常会沦为贫血的，基于CRUD的服务。

>使用协同，可以仅仅触发一个事件，各服务能够简单地订阅这些事件并且做相应处理，缺点是在于我们看不到非常明显的流程视图。
>
>这意味着，需要做一些额外的工作来监控流程，以保证其正确的运行

###RPC & REST

RPC对于数据库耦合无疑是一种进步，但是耦合度仍旧很高，书中提到的例子主要是stub的生成。

> 因为对规格说明进行了修改，所以所有的客户端都需要重新生成stub，无论该客户端是否需要这个新方法

另外一点在于书中也是在强调本地调用和远程调用并不相同这一点上，因为这其中存在的网络，实质上是非常不稳定的。

> 分布式计算中的一个非常注明的错误观点就是“网络是可靠的”。

我们没有必要对远程调用过度抽象，以至于网络因素完全被隐藏起来。

大部分时候我们会将HTTP和REST混淆，是因为大部分时候大家都是在用HTTP来时先rest，但是实质上大家在实现HTTP接口的时候，都不是REST的。

> REST 最重要的一点是资源的概念，一个资源的对外显示方式和内部存储方式之间没有什么耦合

基于HTTP实现REST不是完美的

> 在要求低延迟的场景下，每个HTTP请求的封装开销可能是个问题

>但是我发现使用库会增加复杂度，因为人会不自觉地回到基于HTTP的RPC的思路上去，然后构建出一些共享库在客户端和服务器之间共享代码是非常危险的。

之前讲到，我们在微服务中使用DRY的思想，相对而言是危险的，我们要避免微服务和消费者之间的过度耦合，否则对微服务很小的改动都会引起消费方法的改动。

在此提起在项目中使用OSS的情况，为了使前端能够更好的进行OSS的使用，我在设计好HTTP接口之后，在前端开发了一个package让前端开发进行使用，确实对OSS实现进行了封装，但导致的问题在于，我在修改OSS之后会去进一步修改前端的package，我将会在两个repo中都有相应代码的修改，这就已经体现了高耦合

> 如果开发服务端API和客户端API的是同一批人，那么服务端的逻辑就有可能泄露到客户端中

比如相关OSS鉴权的细节，在客户端中确实有所体现。

> 在同一个服务上使新接口和老接口同时存在。所以在发布一个破坏性修改时，可以部署一个同时包含新老接口的版本

> 使用服务端的聚合接口或API入口，该入口可以对多个后端调用进行编排，并未不同的设备提供定制化的内容。

这种**为前端服务的后端**曾经在项目中被使用到过，主要是用于当时为了更加彻底的进行前后端分离，因此前端在进行开发的时候使用了mockserver，在之后后端开发更进的过程中，则是通过修改mockserver对应的接口来工作的。这个mockserver在之后逐步被替代为一个**为前端服务的后端**，同时，mockserver也是前端与后端协商接口的一个边缘。

这个层级上我们为了部署新老两套接口，倒不是说直接在一个业务逻辑server的内部设置两个prefix不同的api版本来完成版本管理，相应的，我们应该在运维的层次上处理好相应的问题，比如我们可以简单的在Istio框架下进行相应的版本管理，控制流量的流动。