# Thread & Synchronization

这里以java为背景，介绍java有关线程的实现，由于多线程的出现，随即就出现了多线程中有关资源的共享与控制，有关synchronization，我们有相关的方法针对不同的场景来使用不同的方法解决问题。

## Thread

实现thread在编程语言层面上，有不同的方法，在java语言上，实际的实现是由具体的jvm来选择的，我们将进一步对相关方法进行分析。

### 内核线程实现

内核线程(KLT)是直接由操作系统内核支持的线程，线程的调度也直接交由给内核调度器。

优点：线程调度，线程声明周期管理，并不需要更多用户过多的考虑。

缺点： 相关有关线程的操作都需要系统调用，因此系统调用的代价相对较高，需要在用户态和内核态来回切换。

### 用户线程实现

用户线程实现要解决的主要问题，是为了减少系统调用，减少用户态和内核态来回切换。用户线程的生命周期相关事务都是在用户态完成。但是相对的，就是需要用户能够管理好线程，因此需要相关语言提供库或者语言基本的机制进行支持。

### 混合实现

在混合模式实现下，既存在用户线程，也存在轻量级线程。用户线程还是完全建立在用户空间中，因此用户线程的生命周期依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能以及处理器映射。

java的主要实现是使用内核线程建立所谓1:1的线程模型，但是有部分虚拟机会有不同实现方式，这里以主流的Hotpot虚拟机为例。

### 调度

thread调度分为协同式调度和抢占式调度，两种调度的主要区别在于是否存在明显的核心（scheduler）

#### 协同式调度

协同式调度的线程执行时间完全是由正在运行的线程决定的，如若线程忘记进行线程切换，则会出现程序阻塞的情况，而我们作为用户却对此无可奈何。

#### 抢占式调度

抢占式调度拥有明显的核心，线程只能使用时间，当然对于各线程优先级，在java线程中可以进行设置，但是这种设置在内核中的映射，在各种操作系统上，是不相同的，可能在java中是不同级别的线程，但是在相应的系统中，则可能是同一个的等级。

内核线程模型是如今java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷就是切换、调度的成本高昂，系统能容纳的线程数量也很有限。

因此会提出使用基于协同调度的用户态线程——“协程”。

### java协程与golang协程

java的协程和golang的协程，在概念上有着相应的区别。

golang的协程提出是在内核线程上进一步做文章，进一步建立模型，对执行在线程上的函数进行调度，即线程(M)的调度由内核管理，线程上执行什么(G)由线程上的调度器(P)进行管理。因此其敢说自己是轻量级的调度，而实际使用的内核线程数量由参数`gomaxprocs`来决定。

而java的协程，主要是基于用户态线程来实现的，运行时，我们仍旧需要进行线程切换，只是我们在切换时，能够有更多的方法来进行上下文切换，节约更多的时间。

## java多线程资源管理

java多线程的机制下，必然会有一套方法有关于能够完成对于多线程场景下，相应资源如何进行管理

### 线程安全

在论述相应方法之前，我们先对线程安全进行一个描述，这其中的标准是我们的目标。

#### 不可变

不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。

#### 绝对线程安全

线程的绝对安全，并不是体现在方法调用上的（在方法调用上是否使用了synchronized关键字），更加绝对的，是在对应的资源身上，因为操作的线程安全，并不能代表资源的线程安全。

#### 相对线程安全

相对线程安全就相对宽松，只需要单次对资源的操作，是线程安全的即可。我们就可以在方法上设置synchronized来进行串行化执行。

下文提到的方法，我们都会相应的与上文的安全级别进行一个对比。

### 线程安全的实现

#### volatile

volatile是哪个级别，我自己也说不清楚，我更感觉他是一种非常浅层次的线程可见性表述。是对可见性的一种保证——当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。我们对此的应用场景在书中提到两个场景：

1. 运行结果并不爱依赖变量的当前值（true or false）

2. 变量不需要与其他的状态变量共同参与不变约束。

config load和工作线程，工作线程需要等待config loading结束之后，才能开始进行相应的工作。

volatile的具体实现如下

首先是在java字节码中的`getstatic` 和`putstatic`进行具体的体现，在x86架构下，具体体现在`lock`汇编指令上

lock指令的语义为建立一个内存屏障，指重排序时不能把后面的指令重排序到内存屏障之前的位置。

而`lock addl $0x0 (%esp)`指令的语义为，将本处理器的缓存写入内存进行同步，会引起别的处理器或者别的内核无效化其对应的缓存。

### 互斥同步

同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些）线程使用。而互斥是其中一种实现同步的手段。我们在此介绍几种互斥的实现方式

#### synchronized

synchronized关键字最终的实现在字节码上的表现为使用`monitorenter`和`monitorexit`来实现对代码块的控制。synchronized的使用注意事项如下：

1. 同步块对同一条线程来说是可以重入的，这意味着统一鲜橙反复进入同步会不会出现把自己锁死的情况
2. 被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件的阻塞其他线程的进入。

阻塞和唤醒一个线程，需要进入内核态操作，但是相应的状态转换的时间可能比实际执行事务的时间更长。

#### lock

非常传统的方式进行相应的实现，不再是代码块级别的同步，相应的，是对相应资源的管控。Lock

#### 非阻塞同步

