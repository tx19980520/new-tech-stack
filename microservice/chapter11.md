# 规模化微服务

本章节就如何使得微服务不那么脆弱展开讨论。使用了几种不同思虑的方法解决问题。

## 超时

>如果等待时间太长来决定调用失败，整个系统会被拖慢。如果超时太短，你会将一个可能还在正常工作的调用错认为是失败的

超时非常的微妙，因为这个量很难做到动态，比如在系统优化之后，曾经的超时设置就不存在超时所存在的意义，超时这个指标必须对当下的情况有意义。并且超时还有可能跟随着retry，在《google SRE》这本书里面提到过，retry这个操作是需要非常谨慎的，因为retry可能会造成过载的情况，更加容易出现问题。

## 断路器

断路器的主要目的是为了能够保护下游服务，对下游服务进行隔离。对应在《SRE》这本书中，则是跛脚服务的一个体现。服务进入跛脚状态，开始自我诊断，确保自己能够恢复到正常状态。在隔离期间，上游服务的处理根据同步和异步分为两种，如果是同步操作，则直接快速返回失败，如果是异步操作，则相应的请求在积累。但另一个问题会出现，即如果是积累请求（比如使用消息队列），则服务的压力并没有缩小，反而在积累一段时间之后，会触发消息队列本身的汰换机制。

## 舱壁

舱壁和断路器能够结合进行使用，是一种把自己从故障中隔离开的一张方式，微服务本质上就是一种舱壁的思路，更细致的，我们可以为每一个下游服务的连接使用不同的连接池，这样的话，如果一个连接池被用尽，其余连接并不受影响。

超时和断路器能够帮助你在资源受限制时释放它们，但舱壁可以在第一时间确保它们不成为限制。这个问题上实质上在Istio内部是不需要服务自己管理连接池的，是在Istio的代理层上进行了连接池的管理。

## 幂等

幂等操作，是从靠近业务逻辑的角度来进行保证——即使出现服务宕机，也不会出现数据错误等不利影响，他的主要用途是在于，使得从错误中恢复，是较为容易的。幂等的更多操作实质上可以在HTTP规范中被体现，但是规范是规范，至于实现中是否是真实的幂等操作。如果使用了这些动词，但是操作不是幂等的，然而调用者认为它们是可以安全地重复执行，你可能会让自己陷入困境。

## 负载均衡

负载均衡在四层和七层都能够做到，四层失去灵活性，但是在性能上有所突出，七层有更强的灵活性，但是封装上存在相应额外的时间和空间消耗。ingressgateway可以对外使用https来保障安全性，在集群内部为了减少消耗，使用http即可。

## 缓存

使用缓存有诸多的好处，同时也存在相应的问题。

### 为弹性使用缓存

缓存可以在出现故障时实现弹性。使用消费者缓存，如果下游服务不可用，客户端可以先简单地使用缓存中可能失效了的数据。对于一些系统来说，使用失效但可用的数据，比完全不可用的要好。

### 隐藏源服务

> 对于那些提供高度可缓存数据的服务，从设计上讲，源服务本身就只能处理一小部分的流量，因为大多数请求已经被源服务前面的缓存处理了。

> 保护源服务的一种方式是，在第一时间就不要对源服务发起请求。相反，在需要时源服务本身会异步地填充缓存。

在《SRE》这本书中讲到，缓存通常会给人一种假象，即我们的服务能够满足很高的throughput，但实际上，当我们新起的服务可能没有那么强的负载能力，此时就需要先进行缓存的填充，不然我们的服务过载之后会出现断崖式崩塌。