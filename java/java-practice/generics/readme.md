# java泛型

java的泛型到头来的也是语法糖。java的泛型实现是使用擦除式实现的，翻译到具体的字节码中，最终的情况只会认得裸类型，不会认得具体的模板类型，而模板类型的信息，将会在各处调用该实例时，进行强制类型转换来实现

### 裸类型

裸类型将会被视为所有该类型泛型化实例的共同父类，那我们可以认为`ArrayList<Integer>`是

`ArrayList`的子类吗，确实是可以有这样的实现，但是在java中，选择了并不这样实现，强制类型会带来的问题是，原始类型不支持转化为Object。

运行时java是不支持获取到泛型类型，是因为在class中并未记载有相应泛型类型的信息。

但反过来，我们如果自己显式的使用了泛型，我们是能够获取到泛型信息的，因为这个信息是我们显示注入进去的，但是我们在实例的内部，是不能够获取到具体T的类型。

### 类型上界 & 类型下界

类型上界和类型下界这个功能其实不影响java泛型的本质，主要是为了提升类型检查的能力，只能说是一个附加功能，也能让程序员理清逻辑。

```java
Generic<T extends List<String>>;
// T 必须是List<String>或其子类
Generic<? super Fruit>;
// 泛型必须是Fruit或者是该类型的父类
```

### 通配符

通配符的`?`比`T`更加便利，但是一致性就无法保证。

```java
copy(List<T>, List<T>);
// 两个T必定是一样的
copy(List<? extends A>, List<? extends A>);
// 由于通配符是不确定的，所以这个方法不能保证两个List有相同类型的元素
```

T可用于多重限定，如`<T extends A & B>`，通配符`?`不能进行多重限定。但是?可以同时进行两种限定。

