# 类加载流程和类加载机制

本节我们就类加载流程和类加载机制做相关的简介。

## 类加载流程

首先进行名词上的区分，加载是类加载中的一个流程。《java虚拟机规范》中没有固定类加载的实际，但是规定必须在以下的情况中加载类：

1. 遇到new、getstatic、putstatic或invokestatic时必须加载，具体体现在java代码中是new一个对象，获取类的常量（除去静态量进入到常量池中的情况），调用一个类型的静态方法的时候。
2. 使用reflect包的方法对类型进行反射调用的时候，需要进行相应类的初始化。
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。
5. `MethodHandler`中模拟触发相应函数时，必须要对相应的方法所在类进行加载
6. 当一个接口中定义了JDK 8新加入的默认方法，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

除此之外的情况都被称之为被动引用。

书中主要讲了三个例子：

1. 通过子类引用父类的静态字段的，不会导致子类初始化
2. 准备初始化某个数组，此时类不会进行初始化，当等到调用数组内具体事例的具体方法的时候才会初始化。
3. 使用类中的常量，常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

对于接口而言，并不需要其父接口全部都完成了初始化，只有在真正使用到父接口的时候（比如引用接口中定义的常量）才会初始化。

#### 加载

主要完成三件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的接口。

#### 验证

验证又分三个部分：**文件格式验证**、**元数据验证**、**字节码验证**。

**文件格式验证**：主要是针对魔数，版本号，文件整体的结构等是否完整。

**元数据验证**：对字节码描述的信息进行验证，比如这个类是否有父类，父类是不是不可被继承，这个类如果不是抽象类，是否实现了父类或接口中的所有方法。是否存在父类子类的矛盾。

**字节码验证**：主要是通过数据流验证和控制流验证来进行工作。主要是对于操作栈的相关工作，是否是类型合法的，保证跳转的合理性，保证数据类型转换的合理性。我们肯定不能用很多的时间来进行验证，因为我们准备实践换空间，我们在class文件中会存储相StackMapTable，主要是在某一行运行后，描述相应的栈和操作栈的情况。

#### 解析

解析是将java虚拟机常量池内的符号引用替换为直接引用的过程。

**类或接口的解析**：

1. 如果需要解析的不是一个数组类型，则会将其全限定名交给类加载器进行加载，会有一个递归的调用的情况。例如加载这个类的父类或实现的接口。
2. 如果需要解析的是一个数组类型，则会对其元素类型进行类加载。
3. 之后要进行访问权限的检查

**字段解析**：

1. 如果类C本身就包含了简单名称和字段描述符都匹配
2. 否则，如果在C中实现了接口，将会按照继承关系从上往下递归搜索各个接口和它的父接口。
3. 否则，如果C不是Object，则会直按层级进行高层次的递归搜索。
4. 否则，查找失败，抛出NoSuchFieldError异常。

**方法解析和接口方法解析**：

简单讲都是先本地找，之后从继承的父类或者父接口中去找。如果是多接口的情况，但是不同的接口中都存在相同的函数签名， 则会返回其中的一个。

#### 初始化

初始化部分主要关注的点是在clinit是右边一起自动收集类中的所有变量的赋值动作和静态语句块的中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。虚拟机会保证在子类clinit方法执行之前，父类的clinit方法执行完毕。

如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit方法

接口中不能使用静态语句块，但是仍然有变量初始化的赋值操作，但是父接口不会初始化，除非被用到，实现类不会调用接口的clinit

clinit在多线程中是被加锁同步的，多个线程同时去初始化一个类，那么只会有其中一个线程执行这个类的clinit方法。

## 类加载机制

对于任意一个类，都必须由加载器和这个类本身一起共同确立其在java虚拟机中的虚拟性。比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个class文件，被同一个java虚拟机加载，只要加载它们的类加载器不同，那两个类必不相等，即每一个类加载器都是一个新的命名空间。

java虚拟机为了能够保证类的唯一性，则会启动三层类加载模型，通过双亲委派模型来进行类加载。

三层类加载器主要是**启动类加载器**、**扩展类加载器**和**应用程序类加载器**

**启动类加载器**：负责加载存放在`<JAVA_HOME>\lib`目录的类。启动类加载器无法被java程序直接引用，用户在编写自定义加载器时，如果需要把加载请求委派给隐刀类加载器去助力，直接使用null即可。

**扩展类加载器**：负责加载`<JAVA_HOME>\lib\ext`目录。但是在java9之后，这种扩展机制被模块化带来的天然的扩展能力取代。

**应用程序类加载器**：负责加载ClassPath上所有的类库，如果程序中没有自定义过类加载器，一般情况下就直接使用程序中默认的类加载器。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该穿到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成。

双亲委派模型最终都是委派处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。

自定义类加载的用途是在于：

1. 可以用来加密class文件，然后解密Class文件进行再加载，提高系统安全性。比如我们当时准备使用福昕的相关接口，他的jar包是单独发的，然后jar包在具体使用的时候，会进行 key 和secret的检查，否则无权进行使用。
2. 从网络中加载class文件。

