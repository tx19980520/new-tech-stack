# Chapter22 处理连锁故障

连锁处理的主要原因是资源耗尽，并且引发的故事是多米诺骨牌式的故障，为了避免上述的情况，我们需要清楚的认识到资源的情况，进行相应的保障措施来避免连锁故障的发生。

## CPU & Memory

两种资源的性质是不相同的，我们在另一篇博客里面有比较详细的讲述这样的一个问题。在本章节中描述相应资源可能会遇到副作用以及两种资源混合的副作用都需要已经比较详细，我们不一一赘述。

## 连锁故障是断崖式

> “如果某个服务在10,000 QPS的水平下正常服务，但是当11,000QPS的时候进入连锁故障模式，降低负载到9,000 QPS通常也无法恢复。这是因为这是该服务仍然处于容量不足的状态。”

一定要重视连锁故障带来的问题，这样的后果是非常难以接受的。

首先我们要知道我们现在的服务在什么时候会发生过载导致连锁故障。

能够获取相关数据的方式：

1. 在实际情况下的压力测试，要在已经过载情况下再进一步加大压力进行测试。
2. 对一些下游服务进行故障注入（100%的返回500，且delay 非常长的时间）

## 防止服务器过载的方法

### 队列管理

主要是对 消息中间件的使用，这里一般建议队列长度比对应的线程池要小比较合适。

### 流量抛弃

考虑在某个层次抛弃流量，主要考虑在负载均衡层或反向代理层进行该项操作，这个可以用Istio的相关熔断机制来进行实现。

### 请求延迟和截止时间

这个设置比较tricky，你需要对链路上的服务都进行相应时间设置，并且相互是有所影响的，甚至可能因为你的配置不当，导致在超时情况下出现相应的处理了请求但是连接已经关闭的情况，相当于资源被消耗，但请求并不成功（没有返回）。

### cache管理与慢启动

主要是因为cache的存在会让我们的服务变得更快，返回更迅速，但是与此同时带来的就是服务对于cache的依赖，甚至没有cache和有cache的差距会非常的大。

针对java而言，存在JIT编译过程，在长时间运行的情况下，能够将提升相应服务的能力，但是一定要考虑到在过载崩溃的情况下，立即重启的Pod是没有办法恢复到原有的生产力的，此时需要记尽可能的用多个新Pod来替代原有Pod。

### 重试

主要是要进行错峰重试，以及，我们一定要在特定的情况下进行重试，比如我们需要根据返回的status code进行进行判断，并且进行延时重试，这个与Pod内具体进行业务其实有莫大的关系，需要与之内部的timeout进行配合。

### 优雅降级

对于特定服务进行降级，这个降级可能是接口层级，也可能是服务层级，但是具体的实施方案并没有确定，与业务逻辑需要有很强的联系，并且一定需要测试在压力过后，降级开关能否被关闭。

### 停止健康检查导致的任务死亡

主要是在初始化还未结束的情况下，就进行健康检查，这个地方是要区分进程任务的健康检查和服务级别的健康检查，其实对应的就是k8s中的两种probe，对于其进行不同的精细的配置是非常有必要的。