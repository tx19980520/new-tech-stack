# Garbage Collection

本文不就java虚拟机的具体的垃圾收集的算法为主，主要讲求相应主流方法的主要概念。

就现如今了解到的垃圾收集的办法，主要围绕三个问题开展，如何搜索，搜索什么位置，如何处理内存。

如何搜索的问题，我们主要有**引用计数法**和**可达性分析算法**

## 引用计数法

引用计数法就对象头中隐式记录了相应的引用的数量，我们这里是会考虑到成环的情况，这样成环的情况会导致相应的一簇应该被清除掉的内存空间无法释放。但是我们在inode的文件的系统中，却仍旧使用的是refCount的方式，这是因为我们在创建hardLink的时候，会去检查添加之后是否是成环的，从而避免上述成环的情况的，保证文件系统呈现完整的树状结构。

引用计数法非常的原始，并且在使用对象的大多数时间里，其都会使得相应的操作都有性能的影响。

## 可达性分析算法

可达性分析算法主要依靠的数据结构是GC Roots，GC Roots是一切搜索的开端，JAVA中固定可作为GC Roots的对象包含以下几种

1. 在虚拟机栈中的引用对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
2. 在方法区中类静态属性引用的对象，譬如JAVA类的引用类型静态变量。
3. 在方法区中常量引用对象，譬如字符串常量池里的引用。
4. Native方法中的引用对象。
5. JAVA虚拟机虚拟机内部的引用，如基本数据类型对应的Class对象。
6. 所有被同步锁持有的对象。

以GC Roots构建出来的森林中的节点自然相互之间就是引用关系，为了进一步支持引用关系，进一步对引用进行分类。

**强引用** ：例如引用赋值均为的强引用，如果强引用关系存在，垃圾收集器就不会对其进行回收

**软引用**：软引用用于描述一些还有用，但非必须的对象。在系统要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，属于是一种优化。

**弱引用**：弱引用只能保证该引用指向的对象能够活到这个周期结束，之后便不再存在。

**虚引用**：引用并不保证任何生存周期，设置该引用，只是为了获取到一个变量已经被回收的系统消息。

可以为，整个GC Roots的mechanism已经订好了，上述的引用的分层只是为了在Policy层面上能够有更多的操作空间。

而对于收集哪里，这个问题主要是基于分代收集理论。

## 分代收集理论

1. 弱分代假说——绝大多数对象都是朝生夕灭
2. 强分代假说——熬过越多次垃圾收集过程的对象就越难消亡
3. 跨带引用假说——跨带引用相对于同代引用是较少的

因为有了分代收集理论，我们可以对新生代进行频率较高的垃圾回收，对于老年代进行较低频率的回收。这样兼顾了垃圾收集的时间开销和内存空间的有效利用。最后一条确实是会出现相应的跨带引用，对于跨带引用的处理，我们不得不对老年代进行扫描，但是因为假说的存在，我们在老年代的搜索，其实只会有很少一部分存在搜索的必要，因此我们只需要在新生代上建立一个全局的数据结构——Remembered Set，这个结构把老年代划分成若干小块，标识出老年代的哪一块会存在跨代引用。伺候发生在新生代中的GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots中进行扫描。

最后的一个问题，是在于如何处理内存，一共是三种行为——清除、复制、整理。

**清除**是一个默认的行为，清除的直接消除对应内存的使用标记位，清除的执行效率不稳定，并且内存空间碎片化的问题。后面主要的优化都是基于内存空间碎片化进行操作的。

**复制**的行为主要是将容量划分为大小相等的两块，每次都只是使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面。如果大面积的对象都存活，则会出现大量的内存复制，不过分代收集理论提到过绝大多数对象生命都是短暂的，所以相对的消耗是较少的，但是我们的有效内存空间只剩下原来的一半。一种优化方式是，我们将新生代空间划分为三块——一块大Eden空间和两块较小的Survivor空间，每次使用的空间是Eden * 1 + Survivor * 1，之后在进行垃圾收集的时候，会将存活的对象复制进入到另一块当前空闲的Survivor，当然，如果出现Survivor空间不够用的情况，则存在逃生门去使用老年代的相关空间。该优化的主要理论支持是在于弱分代假说。

**整理**的行为是在标记完成之后，按照标记，将所有存活的对象都向内存空间的一端移动，然后直接清理掉边界外的内存。整理是一个移动式的算法。移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能运行。移动对象可能会带来更大的吞吐量，因为碎片化的减少会降低GC的次数。

