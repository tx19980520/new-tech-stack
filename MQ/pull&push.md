# Message Queue Pull & Push Strategy

就Message Queue消费端获取message的两种策略进行简单介绍。

## pull

pull更加倾向于是一个长轮询的机制，当consumer处理完一条信息之后，就会想broker询问下一条消息。

我们这里会进行考虑，就是在较为空闲的情况下，我们如果一直去轮询broker，但是这样会造成cpu空转，也没有获取到实际有用的消息。比较类似于对于retry的一个处理，我们可以选择对于每一次的轮询进行时间间隔倍增，倍增的主要理由是在于我们希望让出更多的CPU时间。但是如果峰值突然到来，我们的broker突然有了不少的信息，但是我们的consumer仍旧不会去获取相关的信息，因为他们在沉睡。我们会想到另外一种机制，就是我们建立TCP长连接，这个时候我们在一次获取信息时，如果broker有消息就直接返回信息，如果没有信息，就直接IO阻塞，开始睡觉，直到broker这边回复相关消息之后再进行相应的操作，在consumer这边写相应的select。这里单独强调一下，RabbitMQ在pull模式下，每次只能获取到一条message，没有批量拉取的API

## push

push在broker和consumer在创建好tcp连接之后，之后的推流方向，就主要是broker向consumer进行message的推送，这里consumer主要是回复ack。如果consumer正在进行message的操作，则进入到BlockQueue之中。这里样策略下，我们主要考虑的是如果我们consumer的处理能力的不太够（大部分情况下，producer的生产能力是一定强于consumer）。这样的情况下我们的consumer可能出现大量的拥堵。并且我们没有办法就不同consumer的处理能力来进行区别对待。当然我们可以通过qos的设置来控制consumer的提前量。

这种情况下，我们要考虑到consumer的相关问题，consumer会存在宕机和网络不畅的情况，consumer如果consumer宕机，但是相关的信息又已经交到其BlockQueue中，这个时候broker确实可以监控到consumer出现问题，但是也不能将其已经被分配的message进行撤回，因为如果相应的consumer只是网络问题，一会又好了，那就可能相应的消息就会出现多次消费的情况。

### 有关kafka & RabbitMQ的选择

我们可能会看到kafka最终选择了只实现pull，RabbitMQ的默认行为是使用push的行为，kafka选择pull是因为，partition保证了不会存在一个partition上出现多个竞争消费者的情况，我们可以利用消息的批处理来实现更高效的消息传递，从而获得更高的吞吐量。而RabbitMQ则是希望能够尽可能的分发一个消息，尽可能的不使用的内存和磁盘来存储消息，只有在达到Qos上限的时候，才会将相应的内容存储。并且对于一个queue，确实会存在多个consumer subscribe的情况，如果用pull的模式，实质上这个指针的移动感觉还需要序列化（或者相对乐观一点的策略），确实也会对性能有不小的影响。当然你也可以考虑使用得SAC，则一个queue只会有一个活跃的consumer，其他的consumer都不会接收到信息，只是为了保证在活跃consumer离开之后的，对其位置进行顶替。

