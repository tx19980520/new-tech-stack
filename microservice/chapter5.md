# 分解单块系统

作者对于分解单块系统的动机从以下几个因素来考虑，在当时项目中，我们对四个部分都进行了一些考虑，我们来进行相关的回顾：

- 改变的速度

  当初决定使用微服务架构的时候，主要是为了更快的更新迭代，因为我们的项目需要在非常快的周期内跟甲方进行意见的交换与沟通。

- 团队结构

  当时整个系统的主要业务逻辑分成两大部分，中间依靠前文唾弃的数据库集成（没错后面我们会继续吐槽这个部分）。因为两个部分分别属于两个团队，因此会分解会更加利于开发和管理。

- 安全

  在我们的OSS模块中存储有相关阿里云的accessKey，为了该敏感信息不容易扩散和蔓延，最终决定将其独立作为一个模块进行管理。

- 技术

  开始尝试使用相关商用PDF生成技术时，为方便其快速测试和部署，决定单独启用一个服务来实现PDF的相关业务。

来到本章节的重点，有关于数据库的拆解，为什么从数据库开始入手呢，是因为数据库是非常多系统设计最为基础的地方，很多时候在对系统进行建模的时候，都会使用到数据库，而且大部分的应用都会使用数据库集成。数据库拆解有以下几个大体的方式：

### 打破外键关系

外键关系是在我自身项目中最不可割舍的一部分，主要就在于，该项目需要相应的外键约束来保证数据的正确性，这是非常重要的一点，但是外键关系如确实影响到分解，则需将外键所带来的好处用业务逻辑的方式进行transaction的实现。

### 共享静态数据

很多文字翻译相关的静态数据直接体现在数据库中，可以认为，数据库中存储了相应的configmap（比如i18n的相关数据）。这一点其实当时也是为了完全服从于DRY的思想。根据书中有关章节的描述，确实应该适当放宽DRY的实施。在此，可以将共享的静态数据作为文件直接存在于各服务中并自行管理。这样做的道理在于，服务中肯定对这些静态数据有着或多或少的依赖，如果使用共享静态数据，等同于是两个服务之间存在间接依赖，如若需要修改静态数据（修改相关的翻译），则会出现的许多服务都需要进行修改才能正常使用，则会出现lock-step的情况。

### 共享数据

共享数据就是简单的两个服务都共享了一张表。这个地方作者的例子有些过于特别，其实退一步讲，我认为应该先考虑，这两个服务是否需要合并的问题，之后我们再考虑他们是不是共享数据的问题，因为如果数据共享，耦合度应该是相当高，是否直接合并会带来更好的效率和更合理的“分解”有待考虑。书中对于共享表的处理是认为我们缺失了领域概念。最终把中间表单独封装成为一个服务，这实质和前文的操作相似，都是一个**提级**的作用在其中。另外一种情况，就是讲表按照某种方式进行拆解，拆解之后的表不存在依赖，但是如果是按照数据库join的角度来思考，实质可能有一些额外的依赖在其中，也是需要业务逻辑实现的transaction来保证数据的正确性。

## 代价

微服务有自身的好处，自然你需要舍弃一些原有的好处。首先是弱化一致性，具体为弱化了相当的数据库原生支持的功能，比如外键约束和transaction，我们对这两个主要的问题的付出的代价如下：

1. 定期对数据进行检查以保证最终一致性，或对于数据库出现不一致的情况进行友好的用户提示和进一步错误处理操作
2. 主动通过更进一步的一致性保证来实现分布式transaction。

